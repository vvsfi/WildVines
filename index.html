<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Saarinenkoti – Marble Ring</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #111; touch-action: none; }
  canvas { display: block; cursor: grab; touch-action: none; }
  canvas:active { cursor: grabbing; }
  #info {
    position: fixed; left: 50%; transform: translateX(-50%);
    font-family: 'Georgia', serif; font-size: 16px; color: rgba(255,255,255,0.95);
    text-shadow: 0 1px 4px rgba(0,0,0,0.7); pointer-events: none;
    letter-spacing: 1.2px;
    background: rgba(0,0,0,0.55);
    padding: 10px 28px;
    border-radius: 24px;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    border: 1px solid rgba(255,255,255,0.25);
    animation: infoHighlight 10s ease-out forwards;
    white-space: nowrap;
  }
  @keyframes infoHighlight {
    0%   { color: rgba(255,255,255,1); background: rgba(0,0,0,0.6); border-color: rgba(255,255,255,0.4); transform: translateX(-50%) scale(1.05); }
    15%  { color: rgba(255,255,255,1); background: rgba(0,0,0,0.55); border-color: rgba(255,255,255,0.35); transform: translateX(-50%) scale(1.02); }
    70%  { color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.4); border-color: rgba(255,255,255,0.2); transform: translateX(-50%) scale(1); }
    100% { color: rgba(255,255,255,0.35); background: rgba(0,0,0,0); border-color: rgba(255,255,255,0); transform: translateX(-50%) scale(1); padding: 10px 28px; backdrop-filter: blur(0px); }
  }
  #graffiti {
    position: fixed; left: 50%; transform: translateX(-50%);
    pointer-events: none; z-index: 10;
  }
  #refreshBtn {
    position: fixed; top: 14px; right: 14px; z-index: 20;
    width: 44px; height: 44px; border-radius: 50%;
    background: rgba(0,0,0,0.45); border: 2px solid rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.8); font-size: 20px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
    transition: transform 0.4s ease, background 0.2s ease;
    padding: 0; line-height: 1;
  }
  #refreshBtn:hover { background: rgba(0,0,0,0.65); }
  #refreshBtn:active { transform: rotate(360deg) scale(0.9); }
  #refreshBtn svg { width: 22px; height: 22px; fill: none; stroke: rgba(255,255,255,0.85); stroke-width: 2.2; stroke-linecap: round; stroke-linejoin: round; }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Bungee+Shade&family=Nabla&family=Rubik+Spray+Paint&family=Emblema+One&display=swap" rel="stylesheet">
</head>
<body>
<canvas id="c"></canvas>
<canvas id="graffiti"></canvas>
<button id="refreshBtn" aria-label="Refresh"><svg viewBox="0 0 24 24"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg></button>
<div id="info">drag a marble to shoot it</div>
<script>

// ─── 3D Graffiti Title Renderer ───
let bgPalette = []; // shared with background generator

function drawGraffitiTitle() {
  const gc = document.getElementById('graffiti');
  const g = gc.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  const gW = Math.min(window.innerWidth * 0.94, 880);
  const gH = 140;
  gc.width = gW * dpr;
  gc.height = gH * dpr;
  gc.style.width = gW + 'px';
  gc.style.height = gH + 'px';
  g.scale(dpr, dpr);

  const text = 'Saarinenkoti';
  const fontSize = Math.min(gW * 0.125, 88);

  const fonts = ['Rubik Spray Paint', 'Bungee Shade', 'Emblema One'];
  const fontChoice = fonts[Math.floor(Math.random() * fonts.length)];
  const fontStr = `bold ${fontSize}px "${fontChoice}", cursive`;
  g.font = fontStr;
  g.textAlign = 'center';
  g.textBaseline = 'middle';

  const cx = gW / 2;
  const cy = gH / 2;

  // Use background palette colors
  const p0 = bgPalette[0] || { h: 20, s: 90, lMin: 45, lMax: 80 };
  const p1 = bgPalette[1] || { h: 40, s: 85, lMin: 50, lMax: 85 };
  const pLast = bgPalette[bgPalette.length - 1] || { h: 30, s: 30, lMin: 85, lMax: 96 };

  const darkH = p0.h, darkS = p0.s;
  const midH = p1.h, midS = p1.s;

  // === 3D extrusion (stacked offset layers) ===
  const depth = Math.round(fontSize * 0.12);
  // Extrusion direction: down-right
  for (let d = depth; d >= 1; d--) {
    const t = d / depth; // 1 at back, 0 at front
    const lum = 18 + t * 15; // dark at back, slightly lighter near front
    g.fillStyle = `hsl(${darkH}, ${darkS * 0.7}%, ${lum}%)`;
    g.font = fontStr;
    g.fillText(text, cx + d * 1.1, cy + d * 1.1);
  }

  // === Main face with gradient from palette ===
  const faceGrad = g.createLinearGradient(cx - gW * 0.3, cy - fontSize * 0.5, cx + gW * 0.15, cy + fontSize * 0.5);
  faceGrad.addColorStop(0, `hsl(${p0.h}, ${p0.s}%, ${p0.lMax}%)`);
  faceGrad.addColorStop(0.45, `hsl(${p1.h}, ${p1.s}%, ${(p1.lMin + p1.lMax) / 2}%)`);
  faceGrad.addColorStop(1, `hsl(${p0.h}, ${p0.s}%, ${p0.lMin + 5}%)`);
  g.fillStyle = faceGrad;
  g.fillText(text, cx, cy);

  // === Outline around face ===
  g.strokeStyle = `hsl(${darkH}, ${darkS * 0.8}%, 15%)`;
  g.lineWidth = fontSize * 0.04;
  g.lineJoin = 'round';
  g.miterLimit = 2;
  g.strokeText(text, cx, cy);

  // === Top highlight (clipped to upper half) ===
  g.save();
  g.beginPath();
  g.rect(0, 0, gW, cy - fontSize * 0.02);
  g.clip();
  g.globalAlpha = 0.3;
  g.fillStyle = `hsl(${pLast.h}, ${pLast.s}%, ${pLast.lMax}%)`;
  g.font = fontStr;
  g.fillText(text, cx, cy);
  g.restore();

  // === Subtle specular dot highlights ===
  g.save();
  g.globalAlpha = 0.15;
  g.fillStyle = '#fff';
  g.font = fontStr;
  g.fillText(text, cx - 1, cy - 1.5);
  g.restore();
}

// ─── Setup ───
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, ringCx, ringCy, ringR;
const FRICTION = 0.997;
const RESTITUTION = 0.85;
const MIN_R = 18, MAX_R = 28;
const MAX_FILL = 0.30; // marbles fill at most 30% of ring area (70% empty)

function calcMarbleCount() {
  const ringArea = Math.PI * ringR * ringR;
  const avgR = (MIN_R + MAX_R) / 2;
  const avgBallArea = Math.PI * avgR * avgR;
  const count = Math.floor((ringArea * MAX_FILL) / avgBallArea);
  return Math.max(3, Math.min(count, 40));
}

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  ringCx = W / 2;
  ringCy = H / 2;
  ringR = Math.min(W, H) * 0.38;
  positionUI();
}

function positionUI() {
  const ringOuterTop = ringCy - ringR - 26; // top of ring border
  const ringOuterBot = ringCy + ringR + 26; // bottom of ring border
  const gEl = document.getElementById('graffiti');
  const iEl = document.getElementById('info');

  // Title goes centered in the gap above the ring
  const titleH = 140;
  const topGap = ringOuterTop;
  const titleTop = Math.max(4, (topGap - titleH) / 2);
  gEl.style.top = titleTop + 'px';

  // Instructions go centered in the gap below the ring
  const botGap = H - ringOuterBot;
  const infoH = iEl.offsetHeight || 40;
  const infoTop = ringOuterBot + Math.max(4, (botGap - infoH) / 2);
  iEl.style.top = infoTop + 'px';
}
window.addEventListener('resize', () => { resize(); generateBackground(); generateRingPattern(); initMarbles(); drawGraffitiTitle(); positionUI(); });
resize();

// ─── Random helpers ───
const rand = (a, b) => a + Math.random() * (b - a);
const randInt = (a, b) => Math.floor(rand(a, b + 1));
const pick = arr => arr[randInt(0, arr.length - 1)];

function hsl(h, s, l) { return `hsl(${h},${s}%,${l}%)`; }
function hsla(h, s, l, a) { return `hsla(${h},${s}%,${l}%,${a})`; }

// ─── Organic swirling candy background ───
let bgCanvas, bgCtx;

// Smooth noise for organic flow
function fbm(x, y, octaves) {
  let val = 0, amp = 1, freq = 1, max = 0;
  for (let i = 0; i < octaves; i++) {
    val += amp * (Math.sin(x * freq * 1.7 + Math.cos(y * freq * 0.9 + i * 5.1)) *
                  Math.cos(y * freq * 1.3 + Math.sin(x * freq * 1.1 + i * 3.7)));
    max += amp;
    amp *= 0.5;
    freq *= 2.1;
  }
  return val / max;
}

function generateBackground() {
  bgCanvas = document.createElement('canvas');
  bgCanvas.width = W; bgCanvas.height = H;
  bgCtx = bgCanvas.getContext('2d');

  // Vibrant candy palette
  const paletteSize = randInt(3, 6);
  const baseHue = rand(0, 360);
  const palette = [];
  const spread = rand(50, 140);
  for (let i = 0; i < paletteSize; i++) {
    palette.push({
      h: (baseHue + (spread / paletteSize) * i + rand(-12, 12) + 360) % 360,
      s: rand(70, 100),
      lMin: rand(38, 52),
      lMax: rand(68, 88)
    });
  }
  // Cream/white accent
  palette.push({ h: (baseHue + rand(-20, 20) + 360) % 360, s: rand(20, 45), lMin: 82, lMax: 96 });

  // Share palette for title
  bgPalette = palette;

  // Strong swirl centers for tight curling
  const swirlCount = randInt(6, 14);
  const swirls = [];
  for (let i = 0; i < swirlCount; i++) {
    swirls.push({
      cx: rand(-0.1, 1.1) * W,
      cy: rand(-0.1, 1.1) * H,
      strength: rand(2.5, 7) * pick([1, -1]),
      radius: rand(0.15, 0.55) * Math.min(W, H)
    });
  }

  function flowAngle(px, py) {
    let angle = fbm(px * 0.002, py * 0.002, 4) * Math.PI * 3;
    for (const s of swirls) {
      const dx = px - s.cx, dy = py - s.cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const influence = Math.exp(-dist * dist / (s.radius * s.radius));
      angle += Math.atan2(dy, dx) * s.strength * influence;
    }
    return angle;
  }

  const diag = Math.sqrt(W * W + H * H);

  // --- LAYER 1: Fat background ribbons that fill the space ---
  const fatCount = randInt(30, 50);
  const fatWidth = diag * rand(0.025, 0.045);
  const STEPS = 400;
  const stepLen = diag * 0.008;

  // Base fill with darkened palette color
  const basePal = palette[0];
  bgCtx.fillStyle = hsl(basePal.h, basePal.s * 0.6, basePal.lMin * 0.55);
  bgCtx.fillRect(0, 0, W, H);

  function tracePath(sx, sy, steps, sLen) {
    const fwd = [{ x: sx, y: sy }];
    let cx = sx, cy = sy;
    for (let s = 0; s < steps; s++) {
      const a = flowAngle(cx, cy);
      cx += Math.cos(a) * sLen;
      cy += Math.sin(a) * sLen;
      fwd.push({ x: cx, y: cy });
    }
    cx = sx; cy = sy;
    const bwd = [];
    for (let s = 0; s < steps; s++) {
      const a = flowAngle(cx, cy);
      cx -= Math.cos(a) * sLen;
      cy -= Math.sin(a) * sLen;
      bwd.push({ x: cx, y: cy });
    }
    bwd.reverse();
    return [...bwd, ...fwd];
  }

  function strokePath(path) {
    bgCtx.beginPath();
    bgCtx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) bgCtx.lineTo(path[i].x, path[i].y);
  }

  function drawRibbon(path, w, pal, litBase) {
    // Dark outline for depth separation
    strokePath(path);
    bgCtx.lineWidth = w * 1.15;
    bgCtx.lineCap = 'round';
    bgCtx.lineJoin = 'round';
    bgCtx.strokeStyle = hsl(pal.h, pal.s * 0.9, Math.max(litBase - 22, 15));
    bgCtx.stroke();

    // Main body
    strokePath(path);
    bgCtx.lineWidth = w;
    bgCtx.strokeStyle = hsl(pal.h, pal.s, litBase);
    bgCtx.stroke();

    // Bright inner band
    strokePath(path);
    bgCtx.lineWidth = w * 0.55;
    bgCtx.strokeStyle = hsl(pal.h, pal.s * 0.85, Math.min(litBase + 16, 92));
    bgCtx.stroke();

    // Hot specular highlight
    strokePath(path);
    bgCtx.lineWidth = w * 0.18;
    bgCtx.strokeStyle = hsla(pal.h, pal.s * 0.4, Math.min(litBase + 35, 97), 0.8);
    bgCtx.stroke();
  }

  // Fat background fill ribbons — densely seeded
  for (let i = 0; i < fatCount; i++) {
    const sx = rand(-W * 0.2, W * 1.2);
    const sy = rand(-H * 0.2, H * 1.2);
    const pal = palette[randInt(0, palette.length - 1)];
    const litBase = rand(pal.lMin, pal.lMax);
    const w = rand(fatWidth * 0.7, fatWidth * 1.4);
    const path = tracePath(sx, sy, STEPS, stepLen);
    drawRibbon(path, w, pal, litBase);
  }

  // --- LAYER 2: Medium ribbons for detail ---
  const medCount = randInt(35, 60);
  const medWidth = diag * rand(0.013, 0.025);
  for (let i = 0; i < medCount; i++) {
    const sx = rand(-W * 0.15, W * 1.15);
    const sy = rand(-H * 0.15, H * 1.15);
    const pal = palette[randInt(0, palette.length - 1)];
    const litBase = rand(pal.lMin, pal.lMax);
    const w = rand(medWidth * 0.6, medWidth * 1.5);
    const path = tracePath(sx, sy, STEPS, stepLen * 0.9);
    drawRibbon(path, w, pal, litBase);
  }

  // --- LAYER 3: Tight spirals / loops on top ---
  const loopCount = randInt(10, 22);
  for (let l = 0; l < loopCount; l++) {
    const lcx = rand(-W * 0.05, W * 1.05);
    const lcy = rand(-H * 0.05, H * 1.05);
    const loopR = rand(25, Math.min(W, H) * 0.22);
    const turns = rand(2, 5.5);
    const pal = palette[randInt(0, palette.length - 1)];
    const lw = rand(diag * 0.008, diag * 0.028);
    const lit = rand(pal.lMin, pal.lMax);
    const startAngle = rand(0, Math.PI * 2);

    // Build spiral path
    const spiralPath = [];
    for (let t = 0; t <= turns * Math.PI * 2; t += 0.06) {
      const shrink = 1 - (t / (turns * Math.PI * 2)) * 0.65;
      const r = loopR * shrink;
      spiralPath.push({
        x: lcx + Math.cos(t + startAngle) * r,
        y: lcy + Math.sin(t + startAngle) * r
      });
    }
    drawRibbon(spiralPath, lw, pal, lit);
  }

  // --- LAYER 4: Thin accent curls ---
  const thinCount = randInt(15, 30);
  for (let i = 0; i < thinCount; i++) {
    const sx = rand(-W * 0.1, W * 1.1);
    const sy = rand(-H * 0.1, H * 1.1);
    const pal = palette[randInt(0, palette.length - 1)];
    const litBase = rand(pal.lMin, pal.lMax);
    const w = rand(diag * 0.004, diag * 0.012);
    const path = tracePath(sx, sy, 250, stepLen * 0.7);
    drawRibbon(path, w, pal, litBase);
  }

  // Soft glow overlay
  const glowGrad = bgCtx.createRadialGradient(W * 0.4, H * 0.35, 0, W * 0.5, H * 0.5, diag * 0.55);
  glowGrad.addColorStop(0, 'rgba(255,255,255,0.05)');
  glowGrad.addColorStop(1, 'rgba(0,0,0,0.1)');
  bgCtx.fillStyle = glowGrad;
  bgCtx.fillRect(0, 0, W, H);
}

// ─── Ring pattern (offscreen) ───
let ringCanvas, ringCtx;
function generateRingPattern() {
  const size = Math.ceil(ringR * 2 + 80);
  ringCanvas = document.createElement('canvas');
  ringCanvas.width = size; ringCanvas.height = size;
  ringCtx = ringCanvas.getContext('2d');
  const cx = size / 2, cy = size / 2;

  // cloud-like colorful ring pattern
  const ringHue1 = rand(0, 360);
  const ringHue2 = (ringHue1 + rand(60, 180)) % 360;
  const ringHue3 = (ringHue1 + rand(120, 240)) % 360;

  // draw multiple overlapping radial gradients for cloud effect
  for (let i = 0; i < 18; i++) {
    const a = rand(0, Math.PI * 2);
    const d = rand(ringR * 0.6, ringR * 1.05);
    const px = cx + Math.cos(a) * d * rand(0.3, 0.7);
    const py = cy + Math.sin(a) * d * rand(0.3, 0.7);
    const blobR = rand(ringR * 0.3, ringR * 0.7);
    const hue = pick([ringHue1, ringHue2, ringHue3]) + rand(-20, 20);
    const grad = ringCtx.createRadialGradient(px, py, 0, px, py, blobR);
    grad.addColorStop(0, hsla(hue, rand(70, 100), rand(55, 80), rand(0.3, 0.6)));
    grad.addColorStop(1, hsla(hue, 80, 60, 0));
    ringCtx.fillStyle = grad;
    ringCtx.fillRect(0, 0, size, size);
  }
}

generateBackground();
generateRingPattern();

// Draw graffiti after fonts are ready
if (document.fonts && document.fonts.ready) {
  document.fonts.ready.then(() => { drawGraffitiTitle(); positionUI(); });
} else {
  setTimeout(() => { drawGraffitiTitle(); positionUI(); }, 500);
}

// ─── Marble generation ───
function createMarble(index) {
  const r = rand(MIN_R, MAX_R);
  // place randomly inside ring
  const angle = rand(0, Math.PI * 2);
  const dist = rand(0, ringR - r - 5);
  const x = ringCx + Math.cos(angle) * dist;
  const y = ringCy + Math.sin(angle) * dist;

  const baseHue = rand(0, 360);
  const sat = rand(40, 100);
  const lit = rand(40, 75);
  // decoration type
  const deco = randInt(0, 5); // 0=swirl, 1=cat-eye, 2=speckles, 3=bands, 4=star, 5=plain

  return {
    x, y, vx: 0, vy: 0, r,
    baseHue, sat, lit, deco,
    swirlAngle: rand(0, Math.PI * 2),
    swirlCount: randInt(2, 5),
    speckles: Array.from({ length: randInt(6, 18) }, () => ({
      a: rand(0, Math.PI * 2), d: rand(0.1, 0.7),
      s: rand(0.04, 0.15), h: rand(0, 360)
    })),
    bands: randInt(2, 5),
    bandAngle: rand(0, Math.PI),
  };
}

let marbles = [];
function initMarbles() {
  marbles = [];
  const count = calcMarbleCount();
  for (let i = 0; i < count; i++) marbles.push(createMarble(i));
  // Safety check: verify actual fill ratio <= 30%
  const ringArea = Math.PI * ringR * ringR;
  while (marbles.length > 3) {
    const totalBallArea = marbles.reduce((sum, b) => sum + Math.PI * b.r * b.r, 0);
    if (totalBallArea / ringArea <= MAX_FILL) break;
    marbles.pop();
  }
}
initMarbles();

// ─── Interaction (touch + mouse) ───
let dragging = null;
let dragStart = null;
let dragCurrent = null;

function getPointerPos(e) {
  if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  if (e.changedTouches && e.changedTouches.length > 0) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
  return { x: e.clientX, y: e.clientY };
}

function onDown(e) {
  e.preventDefault();
  const { x: mx, y: my } = getPointerPos(e);
  // Larger hit area on touch devices
  const isTouch = e.type === 'touchstart';
  const hitPad = isTouch ? 12 : 0;
  for (let i = marbles.length - 1; i >= 0; i--) {
    const b = marbles[i];
    const dx = mx - b.x, dy = my - b.y;
    const hitR = b.r + hitPad;
    if (dx * dx + dy * dy < hitR * hitR) {
      dragging = b;
      dragStart = { x: mx, y: my };
      dragCurrent = { x: mx, y: my };
      b.vx = 0; b.vy = 0;
      break;
    }
  }
}

function onMove(e) {
  if (dragging) {
    e.preventDefault();
    dragCurrent = getPointerPos(e);
  }
}

function onUp(e) {
  if (dragging && dragStart) {
    const { x, y } = getPointerPos(e);
    const dx = dragStart.x - x;
    const dy = dragStart.y - y;
    dragging.vx = dx * 0.25;
    dragging.vy = dy * 0.25;
  }
  dragging = null; dragStart = null; dragCurrent = null;
}

canvas.addEventListener('pointerdown', onDown, { passive: false });
canvas.addEventListener('pointermove', onMove, { passive: false });
canvas.addEventListener('pointerup', onUp);
canvas.addEventListener('pointercancel', onUp);
// Touch fallbacks for older mobile browsers
canvas.addEventListener('touchstart', onDown, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onUp);
canvas.addEventListener('touchcancel', onUp);

// ─── Refresh button ───
document.getElementById('refreshBtn').addEventListener('click', () => {
  generateBackground();
  generateRingPattern();
  initMarbles();
  drawGraffitiTitle();
  positionUI();
  // Re-trigger info animation
  const info = document.getElementById('info');
  info.style.animation = 'none';
  info.offsetHeight; // reflow
  info.style.animation = '';
});

// ─── Physics ───
function physics() {
  for (const b of marbles) {
    if (b === dragging) continue;
    b.x += b.vx;
    b.y += b.vy;
    b.vx *= FRICTION;
    b.vy *= FRICTION;

    // ring containment
    const dx = b.x - ringCx, dy = b.y - ringCy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist + b.r > ringR) {
      const nx = dx / dist, ny = dy / dist;
      b.x = ringCx + nx * (ringR - b.r);
      b.y = ringCy + ny * (ringR - b.r);
      const dot = b.vx * nx + b.vy * ny;
      b.vx -= 2 * dot * nx;
      b.vy -= 2 * dot * ny;
      b.vx *= RESTITUTION;
      b.vy *= RESTITUTION;
    }
  }

  // ball-ball collisions
  for (let i = 0; i < marbles.length; i++) {
    for (let j = i + 1; j < marbles.length; j++) {
      const a = marbles[i], b = marbles[j];
      if (a === dragging || b === dragging) continue;
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = a.r + b.r;
      if (dist < minDist && dist > 0.01) {
        const nx = dx / dist, ny = dy / dist;
        const overlap = minDist - dist;
        const totalMass = a.r * a.r + b.r * b.r;
        a.x -= nx * overlap * (b.r * b.r / totalMass);
        a.y -= ny * overlap * (b.r * b.r / totalMass);
        b.x += nx * overlap * (a.r * a.r / totalMass);
        b.y += ny * overlap * (a.r * a.r / totalMass);

        const dvx = a.vx - b.vx, dvy = a.vy - b.vy;
        const dvDotN = dvx * nx + dvy * ny;
        if (dvDotN > 0) {
          const impulse = (2 * dvDotN / totalMass) * RESTITUTION;
          a.vx -= impulse * b.r * b.r * nx;
          a.vy -= impulse * b.r * b.r * ny;
          b.vx += impulse * a.r * a.r * nx;
          b.vy += impulse * a.r * a.r * ny;
        }
      }
    }
  }
}

// ─── Rendering ───
function drawMarble(b) {
  const { x, y, r, baseHue, sat, lit, deco } = b;
  ctx.save();

  // Base sphere gradient (glass-like)
  const grad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.35, r * 0.05, x, y, r);
  grad.addColorStop(0, hsla(baseHue, sat, Math.min(lit + 35, 95), 0.95));
  grad.addColorStop(0.4, hsla(baseHue, sat, lit, 0.9));
  grad.addColorStop(0.8, hsla(baseHue, sat + 10, lit - 15, 0.88));
  grad.addColorStop(1, hsla(baseHue, sat, lit - 25, 0.85));

  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();

  // Decoration inside
  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, r * 0.92, 0, Math.PI * 2);
  ctx.clip();

  if (deco === 0) {
    // swirl
    for (let s = 0; s < b.swirlCount; s++) {
      ctx.beginPath();
      const sHue = (baseHue + 60 + s * 50) % 360;
      ctx.strokeStyle = hsla(sHue, 80, 65, 0.6);
      ctx.lineWidth = rand(1.5, 3);
      for (let t = 0; t < 50; t++) {
        const a = b.swirlAngle + s * (Math.PI * 2 / b.swirlCount) + t * 0.18;
        const d = t * r * 0.018;
        const px = x + Math.cos(a) * d;
        const py = y + Math.sin(a) * d;
        t === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
  } else if (deco === 1) {
    // cat-eye
    const eyeGrad = ctx.createLinearGradient(x - r, y, x + r, y);
    const eyeHue = (baseHue + 120) % 360;
    eyeGrad.addColorStop(0, hsla(eyeHue, 80, 50, 0));
    eyeGrad.addColorStop(0.35, hsla(eyeHue, 80, 60, 0.5));
    eyeGrad.addColorStop(0.5, hsla(eyeHue, 90, 80, 0.7));
    eyeGrad.addColorStop(0.65, hsla(eyeHue, 80, 60, 0.5));
    eyeGrad.addColorStop(1, hsla(eyeHue, 80, 50, 0));
    ctx.fillStyle = eyeGrad;
    ctx.fillRect(x - r, y - r, r * 2, r * 2);
  } else if (deco === 2) {
    // speckles
    for (const sp of b.speckles) {
      ctx.beginPath();
      const sx = x + Math.cos(sp.a) * sp.d * r;
      const sy = y + Math.sin(sp.a) * sp.d * r;
      ctx.arc(sx, sy, sp.s * r, 0, Math.PI * 2);
      ctx.fillStyle = hsla(sp.h, 70, 70, 0.55);
      ctx.fill();
    }
  } else if (deco === 3) {
    // bands
    ctx.translate(x, y);
    ctx.rotate(b.bandAngle);
    for (let i = 0; i < b.bands; i++) {
      const by = -r + (2 * r / (b.bands + 1)) * (i + 1);
      ctx.fillStyle = hsla((baseHue + 90 + i * 40) % 360, 75, 65, 0.45);
      ctx.fillRect(-r, by - 2.5, 2 * r, 5);
    }
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  } else if (deco === 4) {
    // inner star / flower
    const petals = randInt(4, 7);
    for (let p = 0; p < petals; p++) {
      const a = (Math.PI * 2 / petals) * p;
      ctx.beginPath();
      ctx.ellipse(
        x + Math.cos(a) * r * 0.3,
        y + Math.sin(a) * r * 0.3,
        r * 0.25, r * 0.1, a, 0, Math.PI * 2
      );
      ctx.fillStyle = hsla((baseHue + 150) % 360, 80, 70, 0.45);
      ctx.fill();
    }
  }
  // deco 5 = plain, no extra decoration

  ctx.restore();

  // Glass highlight (top-left)
  const hlGrad = ctx.createRadialGradient(x - r * 0.32, y - r * 0.34, r * 0.02, x - r * 0.2, y - r * 0.2, r * 0.6);
  hlGrad.addColorStop(0, 'rgba(255,255,255,0.75)');
  hlGrad.addColorStop(0.5, 'rgba(255,255,255,0.18)');
  hlGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fillStyle = hlGrad;
  ctx.fill();

  // Small sharp highlight
  ctx.beginPath();
  ctx.arc(x - r * 0.28, y - r * 0.3, r * 0.1, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.fill();

  // Subtle rim
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.strokeStyle = hsla(baseHue, sat, lit - 20, 0.35);
  ctx.lineWidth = 1.2;
  ctx.stroke();

  // Shadow beneath
  const shGrad = ctx.createRadialGradient(x + 3, y + 4, r * 0.2, x + 3, y + 4, r * 1.15);
  shGrad.addColorStop(0, 'rgba(0,0,0,0.12)');
  shGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.beginPath();
  ctx.arc(x + 3, y + 4, r * 1.15, 0, Math.PI * 2);
  ctx.fillStyle = shGrad;
  ctx.fill();

  ctx.restore();
}

function drawRing() {
  ctx.save();

  // Draw the ring pattern as a clipped donut
  const outerR = ringR + 22;
  const innerR = ringR;

  // Shadow
  ctx.beginPath();
  ctx.arc(ringCx, ringCy, outerR + 8, 0, Math.PI * 2);
  ctx.shadowColor = 'rgba(0,0,0,0.5)';
  ctx.shadowBlur = 30;
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fill();
  ctx.shadowBlur = 0;

  // Ring body (donut clip)
  ctx.beginPath();
  ctx.arc(ringCx, ringCy, outerR, 0, Math.PI * 2);
  ctx.arc(ringCx, ringCy, innerR - 18, 0, Math.PI * 2, true);
  ctx.clip();

  // Draw the ring pattern canvas
  const size = ringCanvas.width;
  ctx.drawImage(ringCanvas, ringCx - size / 2, ringCy - size / 2);

  // Add glossy highlight on ring
  const ringGrad = ctx.createRadialGradient(ringCx, ringCy - ringR * 0.2, ringR * 0.5, ringCx, ringCy, outerR);
  ringGrad.addColorStop(0, 'rgba(255,255,255,0.12)');
  ringGrad.addColorStop(0.5, 'rgba(255,255,255,0.04)');
  ringGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
  ctx.fillStyle = ringGrad;
  ctx.fillRect(ringCx - outerR, ringCy - outerR, outerR * 2, outerR * 2);

  ctx.restore();

  // Inner rim highlight
  ctx.beginPath();
  ctx.arc(ringCx, ringCy, innerR - 2, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Outer rim
  ctx.beginPath();
  ctx.arc(ringCx, ringCy, outerR, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawSlingshot() {
  if (!dragging || !dragStart || !dragCurrent) return;
  const dx = dragStart.x - dragCurrent.x;
  const dy = dragStart.y - dragCurrent.y;

  // Draw the pull line
  ctx.beginPath();
  ctx.moveTo(dragging.x, dragging.y);
  ctx.lineTo(dragging.x + dx * 0.6, dragging.y + dy * 0.6);
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Arrow head
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len > 10) {
    const ax = dx / len, ay = dy / len;
    const tipX = dragging.x + dx * 0.6;
    const tipY = dragging.y + dy * 0.6;
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - ax * 10 + ay * 5, tipY - ay * 10 - ax * 5);
    ctx.lineTo(tipX - ax * 10 - ay * 5, tipY - ay * 10 + ax * 5);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fill();
  }
}

// ─── Floor for arena (dark surface) ───
function drawArenaFloor() {
  ctx.save();
  ctx.beginPath();
  ctx.arc(ringCx, ringCy, ringR - 2, 0, Math.PI * 2);
  ctx.clip();
  const floorGrad = ctx.createRadialGradient(ringCx, ringCy - ringR * 0.3, 0, ringCx, ringCy, ringR);
  floorGrad.addColorStop(0, '#2a2a3e');
  floorGrad.addColorStop(0.7, '#1a1a2a');
  floorGrad.addColorStop(1, '#101018');
  ctx.fillStyle = floorGrad;
  ctx.fillRect(ringCx - ringR, ringCy - ringR, ringR * 2, ringR * 2);
  ctx.restore();
}

// ─── Main loop ───
function frame() {
  physics();

  // Clear
  ctx.clearRect(0, 0, W, H);

  // Background
  ctx.drawImage(bgCanvas, 0, 0);

  // Dark vignette
  const vig = ctx.createRadialGradient(ringCx, ringCy, ringR * 0.5, ringCx, ringCy, Math.max(W, H) * 0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);

  // Arena floor
  drawArenaFloor();

  // Ring
  drawRing();

  // Marbles (sorted by y for depth illusion)
  const sorted = [...marbles].sort((a, b) => a.y - b.y);
  for (const b of sorted) drawMarble(b);

  // Slingshot UI
  drawSlingshot();

  requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>
